From 2ad136200fb8f46f96ece023d24b546f3ff32fd1 Mon Sep 17 00:00:00 2001
From: DavidZalman101 <davidzalman.101@gmail.com>
Date: Wed, 2 Jul 2025 11:49:31 +0300
Subject: [PATCH 11/12] lab6 - Exercise 11.

---
 inc/env.h        |   4 ++
 inc/lib.h        |   1 +
 inc/syscall.h    |   1 +
 inc/trap.h       |   1 +
 kern/e1000.c     | 132 +++++++++++++++++++++++++++++++++++++++++++++----------
 kern/e1000.h     |  47 ++++++++++++++++++--
 kern/syscall.c   |  39 +++++++++++++++-
 kern/trap.c      |   9 ++++
 kern/trap.h      |   1 +
 kern/trapentry.S |   3 ++
 lib/syscall.c    |   6 +++
 net/input.c      |  69 +++++++++++++++++++++++++++++
 net/output.c     |   5 ++-
 13 files changed, 290 insertions(+), 28 deletions(-)

diff --git a/inc/env.h b/inc/env.h
index 044c68a..577d1c9 100644
--- a/inc/env.h
+++ b/inc/env.h
@@ -35,6 +35,7 @@ enum {
 	ENV_DYING,
 	ENV_RUNNABLE,
 	ENV_RUNNING,
+	ENV_NET_WAIT,
 	ENV_NOT_RUNNABLE
 };
 
@@ -68,6 +69,9 @@ struct Env {
 	envid_t env_ipc_from;		// envid of the sender
 	int env_ipc_perm;		// Perm of page mapping received
 
+	// lab 6
+	bool e1000_try_to_read_again;
+
 #ifdef IPC_SEND_NO_LOOP
 	// the following fields are essintial to allow the reciever to
 	// collect the data waited for him, if available.
diff --git a/inc/lib.h b/inc/lib.h
index 08b34c6..55ee29f 100644
--- a/inc/lib.h
+++ b/inc/lib.h
@@ -61,6 +61,7 @@ int	sys_ipc_try_send(envid_t to_env, uint32_t value, void *pg, int perm);
 int	sys_ipc_recv(void *rcv_pg);
 unsigned int sys_time_msec(void);
 int sys_net_try_send(void *buf, uint32_t buf_len);
+int sys_net_try_recv(void *buf, uint32_t buf_len);
 
 // This must be inlined.  Exercise for reader: why?
 static __inline envid_t __attribute__((always_inline))
diff --git a/inc/syscall.h b/inc/syscall.h
index 11bc823..7b3d12e 100644
--- a/inc/syscall.h
+++ b/inc/syscall.h
@@ -19,6 +19,7 @@ enum {
 	SYS_ipc_recv,
 	SYS_time_msec,
 	SYS_net_send,
+	SYS_net_try_recv,
 	NSYSCALLS
 };
 
diff --git a/inc/trap.h b/inc/trap.h
index b36aae3..8d5fffd 100644
--- a/inc/trap.h
+++ b/inc/trap.h
@@ -36,6 +36,7 @@
 #define IRQ_KBD          1
 #define IRQ_SERIAL       4
 #define IRQ_SPURIOUS     7
+#define IRQ_E1000       11
 #define IRQ_IDE         14
 #define IRQ_ERROR       19
 
diff --git a/kern/e1000.c b/kern/e1000.c
index 86ffa39..9ca3fbb 100644
--- a/kern/e1000.c
+++ b/kern/e1000.c
@@ -2,6 +2,8 @@
 
 // LAB 6: Your driver code here
 
+int e1000_waiting_counter = 0;
+
 /*
 	Gets called automatically when JOS finds the E1000 dev during boot.
 	Enables the device - allocate memory space/IO ports and interrupt lines.
@@ -52,6 +54,8 @@ transmit_init(void)
 	for (i = 0; i < NTDX; i++) {
 		memset(tx_bufs[i], 0, TDX_BUF_SIZE);
 		tx_queue[i].buf_addr = PADDR(tx_bufs[i]);
+		tx_queue[i].cmd |= E1000_TX_CMD_RS;
+		tx_queue[i].status |= E1000_TX_STAT_DD;
 	}
 
 	// base init
@@ -77,30 +81,32 @@ transmit_init(void)
 	E1000_REG(E1000_TIPG) &= ~(E1000_TIPG_IPGT_MASK | E1000_TIPG_IPGR1_MASK |
 							   E1000_TIPG_IPGR2_MASK);
 	E1000_REG(E1000_TIPG) = (0xa) | (0x4 << 10) | (0x6 << 20);
+	asm volatile("mfence" ::: "memory");
 }
 
 int
 transmit_packet(void *buf, uint32_t buf_len)
 {
-	if (!buf)
-		return -E1000_ERR_IVALID_ARG;
-
 	if (buf_len > TDX_BUF_SIZE)
 		return -E1000_ERR_TX_PKT_TOO_BIG;
 
 	int tail_idx = E1000_REG(E1000_TDT);	
-	if ((tx_queue[tail_idx].cmd & (1 << E1000_TX_CMD_RS_SHIFT)) &&
-		!(tx_queue[tail_idx].status & (1 << E1000_TX_STAT_DD_SHIFT)))
+
+	if (!(tx_queue[tail_idx].status & E1000_TX_STAT_DD))
 		return -E1000_ERR_TX_QUEUE_FULL;
 
+	assert(tx_queue[tail_idx].cmd & E1000_TX_CMD_RS);
+
 	// prepare to insert packet to tx queue
-	memcpy(KADDR(tx_queue[tail_idx].buf_addr), buf, buf_len);
+	memcpy(tx_bufs[tail_idx], buf, buf_len);
 	tx_queue[tail_idx].len = buf_len;
-	tx_queue[tail_idx].cmd = (1 << E1000_TX_CMD_EOP_SHIFT);
-	tx_queue[tail_idx].status &= (1 << E1000_TX_STAT_DD_SHIFT);
+	tx_queue[tail_idx].cmd = E1000_TX_CMD_EOP | E1000_TX_CMD_RS;
+	tx_queue[tail_idx].status &= ~E1000_TX_STAT_DD;
 
-	// insert
+	// insert - make sure all memory was written before and after
+	asm volatile("mfence" ::: "memory");
 	E1000_REG(E1000_TDT) = (tail_idx + 1) % NTDX;
+	asm volatile("mfence" ::: "memory");
 	return 0;
 }
 
@@ -124,21 +130,17 @@ receive_init(void)
 	E1000_REG(E1000_RAH) |= E1000_RAH_AV;
 
 	// init MTA
-	E1000_REG(E1000_MTA) = 0;
-
-	// mem init
-	memset(rx_queue, 0, sizeof(rx_queue));
-	memset(rx_bufs, 0, sizeof(rx_bufs));
-	for (i = 0; i < NRDX; i++) {
-		memset(rx_bufs[i], 0, RDX_BUF_SIZE);
-		rx_queue[i].buf_addr = PADDR(rx_bufs[i]);
-	}
-
+	uint32_t mta_addr = E1000_MTA;
+	for (i = 0; i < 128; i++, mta_addr += 4)
+		E1000_REG(mta_addr) = 0;
+	
 	// base init
+	assert(PADDR(rx_queue) % 16 == 0);
 	E1000_REG(E1000_RDBAL) = PADDR(rx_queue);
 	E1000_REG(E1000_RDBAH) = 0;
 
 	// len init
+	assert(sizeof(rx_queue) % 128 == 0);
 	E1000_REG(E1000_RDLEN) = sizeof(rx_queue);
 
 	// head & tail init
@@ -146,7 +148,93 @@ receive_init(void)
 	E1000_REG(E1000_RDT) = NRDX - 1;
 
 	// control init
-	E1000_REG(E1000_RCTL) &= ~(E1000_RCTL_LBM | E1000_RDMTS |
-							   E1000_RCTL_SZ | E1000_RCTL_BSEX);
-	E1000_REG(E1000_RCTL) |= (E1000_RCTL_EN | E1000_RCTL_SECRC);
+	E1000_REG(E1000_RCTL) &= ~E1000_RCTL_LPE; // Disable Long packets
+	E1000_REG(E1000_RCTL) &= ~E1000_RCTL_LBM; // loopback mode - normal operation
+
+	// RDMT
+	E1000_REG(E1000_RCTL) &= ~E1000_RCTL_RDMTS; // clear
+	E1000_REG(E1000_RCTL) |= E1000_RCTL_RDMTS_QUAT; // set
+
+	// MO
+	E1000_REG(E1000_RCTL) &= ~(E1000_RCTL_MO_1 | E1000_RCTL_MO_2 | E1000_RCTL_MO_3); // clear
+	E1000_REG(E1000_RCTL) |= E1000_RCTL_MO_0; // set
+
+	// BAM
+	E1000_REG(E1000_RCTL) |= E1000_RCTL_BAM;
+
+	// Buf Size/Extension
+	E1000_REG(E1000_RCTL) &= ~E1000_RCTL_BSEX; // clear
+	E1000_REG(E1000_RCTL) &= ~(E1000_RCTL_SZ_1024 | E1000_RCTL_SZ_512 | E1000_RCTL_SZ_256); // clear
+	// 00b -> 2048b // set
+
+	// Strip CRC
+	E1000_REG(E1000_RCTL) |= E1000_RCTL_SECRC;
+
+	// mem init
+	memset(rx_queue, 0, sizeof(rx_queue));
+	for (i = 0; i < NRDX; i++) {
+		memset(rx_bufs[i], 0, RDX_BUF_SIZE);
+		rx_queue[i].buf_addr = PADDR(rx_bufs[i]);
+		rx_queue[i].status = 0;
+	}
+
+	// Enable
+	asm volatile("mfence" ::: "memory");
+	E1000_REG(E1000_RCTL) |= E1000_RCTL_EN;
+	asm volatile("mfence" ::: "memory");
+
+	// Intr
+	E1000_REG(E1000_IMC) = 0xffffffff;  // Clear all interrupts first
+	E1000_REG(E1000_IMS) = E1000_IMS_RXDMT0 | E1000_IMS_RXT0 | E1000_ICR_TXQE;
+	irq_setmask_8259A(irq_mask_8259A & ~(1<<11));
+}
+
+int
+receive_packet(void *buf, uint32_t buf_len)
+{
+	static int next_idx = 0;
+	int to_copy = 0;
+	uint32_t rec_buf_len = rx_queue[next_idx].len;
+
+	// check if queue is empty
+	if (!(rx_queue[next_idx].status & E1000_RXD_STAT_DD))
+		return -E1000_ERR_RX_QUEUE_EMPTY;
+
+	// check if the packet has legal len
+	if (rec_buf_len > RDX_BUF_SIZE)
+		return -E1000_ERR_RX_PKT_TOO_BIG;
+
+	// copy to buffer
+	to_copy = buf_len < rec_buf_len ? buf_len : rec_buf_len;
+	memcpy(buf, rx_bufs[next_idx], to_copy);
+	asm volatile("mfence" ::: "memory");
+
+	// clear the packet and move the tail
+	rx_queue[next_idx].status &= ~E1000_RXD_STAT_DD;
+	asm volatile("mfence" ::: "memory");
+	E1000_REG(E1000_RDT) = next_idx;
+	asm volatile("mfence" ::: "memory");
+	next_idx = (next_idx + 1) % NRDX;
+	return to_copy;
+}
+
+void
+e1000_interrupt(void)
+{
+	int i;
+	uint32_t icr = E1000_REG(E1000_ICR);
+	//(void)icr;
+	asm volatile("mfence" ::: "memory");
+
+	if (!(icr & (E1000_ICR_RXT0 | E1000_ICR_RXDMT0)))
+		return;
+
+	// wake up all the envs whome are waiting on net
+	for (i = 0; i < NENV; i++)
+		if (envs[i].env_status == ENV_NET_WAIT) {
+			//cprintf("~~~> e1000_intr: waking up %d\n", envs[i].env_id);
+			envs[i].env_status = ENV_RUNNABLE;
+		}
+	
+	return;
 }
diff --git a/kern/e1000.h b/kern/e1000.h
index a9d892d..ea16f09 100644
--- a/kern/e1000.h
+++ b/kern/e1000.h
@@ -4,6 +4,8 @@
 // Includes
 #include <kern/pci.h>
 #include <kern/pmap.h>
+#include <kern/picirq.h>
+#include <kern/env.h>
 #include <inc/string.h>
 
 // Defines
@@ -58,6 +60,9 @@
 #define E1000_TX_STAT_LC_SHIFT     0x02 /* TX Status LC     */
 #define E1000_TX_STAT_RSV_RU_SHIFT 0x03 /* TX Status RSV-TU */
 
+#define E1000_TX_STAT_DD		   0x01 /* TX Status DD */
+
+
 /* Transmit Descriptor Command */
 #define E1000_TX_CMD_EOP_SHIFT     0x00 /* TX CMD EOP     */
 #define E1000_TX_CMD_IFCS_SHIFT    0x01 /* TX CMD IFCS    */
@@ -68,6 +73,9 @@
 #define E1000_TX_CMD_VLE_SHIFT     0x06 /* TX CMD VLE     */
 #define E1000_TX_CMD_IDE_SHIFT     0x07 /* TX CMD IDE     */
 
+#define E1000_TX_CMD_RS		       0x08 /* TX CMD  RS       */
+#define E1000_TX_CMD_EOP		   0x01 /* TX CMD  RS       */
+
 /* Transmit Descriptor TIPG */
 # define E1000_TIPG_IPGT_MASK  0x000003FF
 # define E1000_TIPG_IPGR1_MASK 0x000FFC00
@@ -85,14 +93,32 @@
 #define E1000_RDT    0x02818 /* RX Descriptor Tail - RW                     */
 #define E1000_RCTL   0x00100 /* RX Control - RW                             */
 
+
 /* Receive Control */
 #define E1000_RCTL_EN    0x00000002 /* enable                */
+#define E1000_RCTL_LPE   0x00000020 /* long packet enable    */
 #define E1000_RCTL_LBM   0x000000c0 /* loopback mode         */
-#define E1000_RDMTS      0x00000300 /* Min Threshold Size    */
 #define E1000_RCTL_SZ    0x00030000 /* rx buffer size        */
 #define E1000_RCTL_BSEX  0x02000000 /* Buffer size extension */
 #define E1000_RCTL_SECRC 0x04000000 /* strip ethernet CRC    */
 
+// MO
+#define E1000_RCTL_MO_SHIFT 12         /* multicast offset shift */
+#define E1000_RCTL_MO_0     0x00000000 /* multicast offset 11:0  */
+#define E1000_RCTL_MO_1     0x00001000 /* multicast offset 12:1  */
+#define E1000_RCTL_MO_2     0x00002000 /* multicast offset 13:2  */
+#define E1000_RCTL_MO_3     0x00003000 /* multicast offset 15:4  */
+#define E1000_RCTL_MDR      0x00004000 /* multicast desc ring 0  */
+
+// RDMTS
+#define E1000_RCTL_RDMTS       0x00000300 /* Min Threshold Size         */
+#define E1000_RCTL_RDMTS_HALF  0x00000000 /* rx desc min threshold size */
+#define E1000_RCTL_RDMTS_QUAT  0x00000100 /* rx desc min threshold size */
+#define E1000_RCTL_RDMTS_EIGTH 0x00000200 /* rx desc min threshold size */
+
+// BAM
+#define E1000_RCTL_BAM 0x00008000    /* broadcast enable */
+
 /* these buffer sizes are valid if E1000_RCTL_BSEX is 0 */
 #define E1000_RCTL_SZ_2048 0x00000000 /* rx buffer size 2048 */
 #define E1000_RCTL_SZ_1024 0x00010000 /* rx buffer size 1024 */
@@ -128,14 +154,26 @@
 #define E1000_RXD_SPC_CFI_MASK  0x1000 /* CFI is bit 12 */
 #define E1000_RXD_SPC_CFI_SHIFT 12
 
+/* Intrrupts */
+#define E1000_IMS 	     0x000D0    /* Interrupt Mask Set - RW      */
+#define E1000_IMC 	     0x000D8    /* Interrupt Mask Clear - WO    */
+#define E1000_IMS_RXDMT0 0x00000010 /* rx desc min. threshold       */
+#define E1000_ICR_RXT0   0x00000080 /* rx timer intr (ring 0)       */
+#define E1000_IMS_RXT0   0x00000080 /* rx timer intr                */
+#define E1000_ICR        0x000C0    /* Interrupt Cause Read - R/clr */
+#define E1000_ICR_RXDMT0 0x00000010 /* rx desc min. threshold (0)   */
+#define E1000_ICR_TXQE   0x00000002 /* Transmit Queue empty         */
+
 // Errors
 #define E1000_ERR_IVALID_ARG     1
 #define E1000_ERR_TX_QUEUE_FULL  2
 #define E1000_ERR_TX_PKT_TOO_BIG 3
+#define E1000_ERR_RX_PKT_TOO_BIG 4
+#define E1000_ERR_RX_QUEUE_EMPTY 5
 
 // Constants
 #define NTDX         64   /* Number of TDESC      */
-#define TDX_BUF_SIZE 1536 /* Tranmist Buffer Size */
+#define TDX_BUF_SIZE 2048 /* Tranmist Buffer Size */
 #define NRDX         128  /* Number of RDESC      */
 #define RDX_BUF_SIZE 2048 /* Receive Buffer Size  */
 
@@ -168,10 +206,13 @@ uint8_t tx_bufs[NTDX][TDX_BUF_SIZE];
 struct rx_desc rx_queue[NRDX] __attribute__((aligned(16)));
 uint8_t rx_bufs[NRDX][RDX_BUF_SIZE];
 
+extern int e1000_waiting_counter;
+
 // Function Declartions
 int e1000_attach(struct pci_func *);
 static void transmit_init(void);
 static void receive_init(void);
 int transmit_packet(void *, uint32_t );
-
+int receive_packet(void *, uint32_t);
+void e1000_interrupt(void);
 #endif	// JOS_KERN_E1000_H
diff --git a/kern/syscall.c b/kern/syscall.c
index dababc5..88017e7 100644
--- a/kern/syscall.c
+++ b/kern/syscall.c
@@ -573,7 +573,40 @@ static int
 sys_net_try_send(void *buf, uint32_t buf_len)
 {
 	user_mem_assert(curenv, buf, buf_len, PTE_U);
-	return transmit_packet((uint8_t*) buf, buf_len);
+	int res = transmit_packet((uint8_t*) buf, buf_len);
+
+	if (res == -E1000_ERR_TX_QUEUE_FULL) {
+		// go sleep
+		curenv->env_tf.tf_regs.reg_eax = -E1000_ERR_RX_QUEUE_EMPTY;
+		curenv->env_status = ENV_NET_WAIT;
+		sched_yield();
+	}
+
+	return res;
+}
+
+/*
+	Recieve a packet with E1000.
+	return values:
+		-E1000_ERR_IVALID_ARG
+		-E1000_ERR_RX_PKT_TOO_BIG
+		-E1000_ERR_RX_QUEUE_FULL
+		0+ = number of bytes read from buffer (Success)
+*/
+static int
+sys_net_try_recv(void *buf, uint32_t buf_len)
+{
+	user_mem_assert(curenv, buf, buf_len, PTE_U);
+	int res = receive_packet(buf, buf_len);
+
+	if (res == -E1000_ERR_RX_QUEUE_EMPTY) {
+		// go sleep
+		curenv->env_tf.tf_regs.reg_eax = -E1000_ERR_RX_QUEUE_EMPTY;
+		curenv->env_status = ENV_NET_WAIT;
+		sched_yield();
+	}
+
+	return res;
 }
 
 // Dispatches to the correct kernel function, passing the arguments.
@@ -652,6 +685,10 @@ syscall(uint32_t syscallno, uint32_t a1, uint32_t a2, uint32_t a3, uint32_t a4,
 			r_val = sys_net_try_send((void*) a1, (uint32_t) a2);
 			goto done;
 
+		case SYS_net_try_recv:
+			r_val = sys_net_try_recv((void*) a1, (uint32_t) a2);
+			goto done;
+
 		default:
 			r_val = -E_INVAL;
 	}
diff --git a/kern/trap.c b/kern/trap.c
index 9bae126..34d3a92 100644
--- a/kern/trap.c
+++ b/kern/trap.c
@@ -270,6 +270,15 @@ trap_dispatch(struct Trapframe *tf)
 			serial_intr();
 			return;
 
+		// e1000 interrupt
+		case IRQ_OFFSET + IRQ_E1000:
+			//cprintf("~~~> kern/trap: Caught IRQ_OFFSET + IRQ_E1000 Intrrupt\n");
+			e1000_interrupt();	
+			lapic_eoi();
+			irq_eoi();
+			return;
+			
+
 		default:
 			goto bad;
 	}
diff --git a/kern/trap.h b/kern/trap.h
index 36b8758..d9d9ff7 100644
--- a/kern/trap.h
+++ b/kern/trap.h
@@ -6,6 +6,7 @@
 # error "This is a JOS kernel header; user programs should not #include it"
 #endif
 
+#include <kern/e1000.h>
 #include <inc/trap.h>
 #include <inc/mmu.h>
 
diff --git a/kern/trapentry.S b/kern/trapentry.S
index 50a3263..5a4b7d5 100644
--- a/kern/trapentry.S
+++ b/kern/trapentry.S
@@ -148,6 +148,9 @@ TRAPHANDLER_NOEC(t_irq_serial, IRQ_OFFSET + IRQ_SERIAL, 0)
 // spurious
 TRAPHANDLER_NOEC(t_irq_spurious, IRQ_OFFSET + IRQ_SPURIOUS, 0)
 
+// E1000
+TRAPHANDLER_NOEC(t_irq_e1000, IRQ_OFFSET + IRQ_E1000, 0)
+
 // ide
 TRAPHANDLER_NOEC(t_irq_ide, IRQ_OFFSET + IRQ_IDE, 0)
 
diff --git a/lib/syscall.c b/lib/syscall.c
index 85080fd..bf06329 100644
--- a/lib/syscall.c
+++ b/lib/syscall.c
@@ -128,3 +128,9 @@ sys_net_try_send(void *buf, uint32_t buf_len)
 {
 	return syscall(SYS_net_send, 0, (uint32_t)buf, (uint32_t)buf_len, 0, 0, 0);
 }
+
+int
+sys_net_try_recv(void *buf, uint32_t buf_len)
+{
+	return syscall(SYS_net_try_recv, 0, (uint32_t)buf, (uint32_t)buf_len, 0, 0, 0);
+}
diff --git a/net/input.c b/net/input.c
index 4e08f0f..bd8f598 100644
--- a/net/input.c
+++ b/net/input.c
@@ -1,7 +1,26 @@
 #include "ns.h"
+#include <inc/lib.h>
+#include <inc/env.h>
+
+#define E1000_ERR_RX_QUEUE_EMPTY 5
+#define BUF_SIZE 2048
 
 extern union Nsipc nsipcbuf;
 
+/*
+	This piece of F*cking Sh*t almost made me cry
+	Who the F*ck would have thought that even with yielding
+	the cpu, sometimes the hint wouldn't have helped.
+	F*ck this - I solve it by addeing 16 pages to work on
+
+	F*ck 
+	F*ck 
+	F*ck 
+	F*ck 
+	F*ck 
+	F*ck 
+*/
+
 void
 input(envid_t ns_envid)
 {
@@ -13,4 +32,54 @@ input(envid_t ns_envid)
 	// Hint: When you IPC a page to the network server, it will be
 	// reading from it for a while, so don't immediately receive
 	// another packet in to the same physical page.
+	char *bufs[16];
+	char *va = (char*)0x0ffff000;
+	int i;
+
+	for (i = 0; i < 16; i++) {
+		sys_page_alloc(0, va, PTE_P | PTE_U | PTE_W);
+		bufs[i] = va;
+		va += PGSIZE;
+	}
+
+	uint8_t buf[BUF_SIZE] = {0};
+	int sys_ret = 0;
+	int current_buffer = 0;
+
+	while (1) {
+		// build req
+		union Nsipc *nsipc = (union Nsipc *) bufs[current_buffer];
+		char *packet_buf = (nsipc->pkt).jp_data;
+		// - read a packet from the device driver
+		//cprintf("net/input: calling syscall net input with :( %d=buf_len %p=buf\n", BUF_SIZE, packet_buf);
+
+		while ((sys_ret = sys_net_try_recv(packet_buf, BUF_SIZE)) == -E1000_ERR_RX_QUEUE_EMPTY) {
+			// noice
+		}
+
+		//cprintf("net/input: returned from syscall net input with :( %d=buf_len %p=buf\n", BUF_SIZE, packet_buf);
+
+
+		assert(sys_ret != -E1000_ERR_RX_QUEUE_EMPTY);
+
+		if (sys_ret < 0)
+			panic("%s: sys_net_try_recv returned %u\n", binaryname, sys_ret);
+
+		(nsipc->pkt).jp_len = sys_ret;
+		ipc_send(ns_envid, NSREQ_INPUT, nsipc, PTE_P | PTE_W | PTE_U);
+		current_buffer = (current_buffer + 1) % 16;
+		sys_yield(); // hint
+		sys_yield(); // hint
+		sys_yield(); // hint
+
+		// send it to the network server - IPC
+		//nsipcbuf.pkt.jp_len = sys_ret;
+		//memcpy(nsipcbuf.pkt.jp_data, buf, sys_ret);
+		//ipc_send(ns_envid, NSREQ_INPUT, &nsipcbuf, PTE_P | PTE_U);
+
+		//sys_yield(); // hint
+		//sys_yield(); // hint
+		//sys_yield(); // hint
+		//memset(buf, 0, sizeof(buf));
+	}
 }
diff --git a/net/output.c b/net/output.c
index a308f47..2bcaa3e 100644
--- a/net/output.c
+++ b/net/output.c
@@ -26,7 +26,8 @@ output(envid_t ns_envid)
 		}
 
 		//	- send the packet to the device driver
-		while (sys_net_try_send((void*)nsipcbuf.pkt.jp_data, nsipcbuf.pkt.jp_len) == -NS_TX_QUEUE_FULL)
-			sys_yield(); // go sleep - hopefully next time you wake up, the queue will have space.
+		while (sys_net_try_send((void*)nsipcbuf.pkt.jp_data, nsipcbuf.pkt.jp_len) == -NS_TX_QUEUE_FULL) {
+			//sys_yield(); // go sleep - hopefully next time you wake up, the queue will have space.
+		}
 	}
 }
-- 
1.9.1

