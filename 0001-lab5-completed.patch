From 0a5840a09a5b4b327f51cc9e50165220a9abd945 Mon Sep 17 00:00:00 2001
From: DavidZalman101 <davidzalman.101@gmail.com>
Date: Sat, 31 May 2025 12:38:43 +0300
Subject: [PATCH 01/12] lab5 completed completed challenge 2

---
 fs/bc.c              | 81 ++++++++++++++++++++++++++++++++++++++++++++++++++--
 fs/fs.c              | 74 ++++++++++++++++++++++++++++++++++++++++++++---
 fs/serv.c            | 29 +++++++++++++++++--
 kern/env.c           |  8 ++++--
 kern/init.c          |  1 +
 kern/syscall.c       | 28 +++++++++++++++++-
 kern/trap.c          | 10 +++++++
 lab5-questionary.txt | 71 +++++++++++++++++++++++++++++++++++++++++++++
 lib/file.c           | 15 +++++++++-
 lib/fork.c           | 16 +++++++++--
 lib/spawn.c          | 16 +++++++++++
 user/sh.c            | 10 ++++++-
 12 files changed, 343 insertions(+), 16 deletions(-)
 create mode 100644 lab5-questionary.txt

diff --git a/fs/bc.c b/fs/bc.c
index 1825555..f1ebfed 100644
--- a/fs/bc.c
+++ b/fs/bc.c
@@ -1,6 +1,13 @@
 
 #include "fs.h"
 
+
+#ifdef BC_EVICT
+void bc_evict(void);
+static size_t cached_block_count = 0;
+#endif
+
+
 // Return the virtual address of this disk block.
 void*
 diskaddr(uint32_t blockno)
@@ -30,8 +37,17 @@ static void
 bc_pgfault(struct UTrapframe *utf)
 {
 	void *addr = (void *) utf->utf_fault_va;
+	void* addr_aligned = ROUNDDOWN(addr, SECTSIZE);
 	uint32_t blockno = ((uint32_t)addr - DISKMAP) / BLKSIZE;
 	int r;
+	bool tried_to_make_space = 0;
+
+#ifdef BC_EVICT
+	if (cached_block_count >= 64)
+		bc_evict();
+	
+	cached_block_count++;
+#endif
 
 	// Check that the fault was within the block cache region
 	if (addr < (void*)DISKMAP || addr >= (void*)(DISKMAP + DISKSIZE))
@@ -48,10 +64,17 @@ bc_pgfault(struct UTrapframe *utf)
 	// the disk.
 	//
 	// LAB 5: you code here:
+	// allocate a page
+	if ((r = sys_page_alloc(0, addr_aligned, PTE_U | PTE_P | PTE_W)) != 0)
+		panic("bc_pgfault: sys_page_alloc %e", r);
+
+	// read from disk to the allocated page
+	if ((r = ide_read(blockno * BLKSECTS, addr_aligned, BLKSECTS)) != 0)
+		panic("bc_pgfault: ide_read %e", r);
 
 	// Clear the dirty bit for the disk block page since we just read the
 	// block from disk
-	if ((r = sys_page_map(0, addr, 0, addr, uvpt[PGNUM(addr)] & PTE_SYSCALL)) < 0)
+	if ((r = sys_page_map(0, addr_aligned, 0, addr_aligned, uvpt[PGNUM(addr_aligned)] & PTE_SYSCALL)) < 0)
 		panic("in bc_pgfault, sys_page_map: %e", r);
 
 	// Check that the block we read was allocated. (exercise for
@@ -72,13 +95,67 @@ void
 flush_block(void *addr)
 {
 	uint32_t blockno = ((uint32_t)addr - DISKMAP) / BLKSIZE;
+	int r;
 
 	if (addr < (void*)DISKMAP || addr >= (void*)(DISKMAP + DISKSIZE))
 		panic("flush_block of bad va %08x", addr);
 
 	// LAB 5: Your code here.
-	panic("flush_block not implemented");
+	void *addr_aligned = ROUNDDOWN(addr, BLKSIZE);
+
+	if (!va_is_mapped(addr_aligned) || !va_is_dirty(addr_aligned))
+		return;
+
+	// mapped and dirty -- write to disk
+	if ((r = ide_write(blockno * BLKSECTS, addr_aligned, BLKSECTS)) != 0)
+		panic("flush_block: ide_write: %e", r);
+
+	// clear the dirty bit
+	if ((r = sys_page_map(0, addr_aligned, 0, addr_aligned, uvpt[PGNUM(addr_aligned)] & PTE_SYSCALL)) < 0)
+		panic("in bc_pgfault, sys_page_map: %e", r);
+}
+
+#ifdef BC_EVICT
+// Evict blocks that are no longer in use.
+void
+bc_evict(void)
+{
+	// NOTE: here we relay on a block size of be = PGSIZE
+	int r, blockno;
+	void *addr;
+	pte_t pte;
+
+	for (blockno = 1; blockno < super->s_nblocks; blockno++) {
+
+		addr = diskaddr(blockno);
+		pte = uvpt[PGNUM(addr)];
+
+		// skip unmapped
+		if ((pte & PTE_P) != PTE_P)
+			continue;
+
+		// page recently used - mark it as unused
+		// if it is really used, the hardware will mark it
+		// accessed again, o.w. someone is hogging the block.
+		if ((pte & PTE_A) == PTE_A) {
+			// clear the Accessed Bit
+			if ((r = sys_page_map(0, (void*) addr, 0, (void*) addr, (pte & PTE_SYSCALL) & ~PTE_A)) != 0)
+				panic("bc_evict: sys_page_map: %e", r);
+			continue;
+		}
+
+		// evict
+		// dirty? flush
+		if ((pte & PTE_D) == PTE_D)
+			flush_block((void*) addr);
+
+		if ((r = sys_page_unmap(0, (void*) addr)) != 0)
+			panic("bc_evict: sys_page_unmap: %e", r);
+
+		cached_block_count--;
+	}
 }
+#endif
 
 // Test that the block cache works, by smashing the superblock and
 // reading it back.
diff --git a/fs/fs.c b/fs/fs.c
index 448dccd..dc08221 100644
--- a/fs/fs.c
+++ b/fs/fs.c
@@ -29,6 +29,17 @@ check_super(void)
 bool
 block_is_free(uint32_t blockno)
 {
+	/*
+		Quick refrence:
+		the bitmap is treated as an array of 32bit integer
+		therefore, each element represents 32 blocks (1 bit per block)
+
+		So in order to check on block blockno we first
+		find the element of 32 blocks that blockno belongs to
+		-- bitmap[blockno / 32]
+		Then, we find this place inside those 32 blocks
+		-- bitmap[block / 32] & (1 << (blockno % 32))
+	*/
 	if (super == 0 || blockno >= super->s_nblocks)
 		return 0;
 	if (bitmap[blockno / 32] & (1 << (blockno % 32)))
@@ -62,7 +73,18 @@ alloc_block(void)
 	// super->s_nblocks blocks in the disk altogether.
 
 	// LAB 5: Your code here.
-	panic("alloc_block not implemented");
+	size_t i;
+
+	for (i = 0; i < super->s_nblocks; i++) {
+		if (!block_is_free(i))
+			continue;
+
+		// found a free block
+		bitmap[i/32] &= ~(1<<(i%32));
+		flush_block(&bitmap[i]);
+		return i;
+	}
+
 	return -E_NO_DISK;
 }
 
@@ -112,7 +134,7 @@ fs_init(void)
 	// Set "bitmap" to the beginning of the first bitmap block.
 	bitmap = diskaddr(2);
 	check_bitmap();
-	
+
 }
 
 // Find the disk block number slot for the 'filebno'th block in file 'f'.
@@ -135,7 +157,36 @@ static int
 file_block_walk(struct File *f, uint32_t filebno, uint32_t **ppdiskbno, bool alloc)
 {
        // LAB 5: Your code here.
-       panic("file_block_walk not implemented");
+	   int blknum;
+
+	   if (filebno >= NDIRECT + NINDIRECT)
+		   return -E_INVAL;
+
+	   if (filebno < NDIRECT) { /* Direct block number */
+			*ppdiskbno = &f->f_direct[filebno];
+			return 0;
+	   }
+
+	   /* Indirect block number */
+	   if (!f->f_indirect) {
+		   	// indirect block is not allocated
+		   	if (!alloc)
+				return -E_NOT_FOUND;
+
+			// allocatd the indirect block
+			if ((blknum = alloc_block()) < 0)
+				return -E_NO_DISK;
+
+			// dont forget to clear the block allocated
+			memset(diskaddr(blknum), 0, BLKSIZE);
+
+			f->f_indirect = blknum;
+	   }
+
+		// indirect block exists
+		*ppdiskbno = &((uint32_t *)diskaddr(f->f_indirect))[filebno - NDIRECT];
+
+		return 0;
 }
 
 // Set *blk to the address in memory where the filebno'th
@@ -150,7 +201,22 @@ int
 file_get_block(struct File *f, uint32_t filebno, char **blk)
 {
        // LAB 5: Your code here.
-       panic("file_get_block not implemented");
+	   int r;
+	   uint32_t *pdiskbno;
+	   if ((r = file_block_walk(f, filebno, &pdiskbno, 1)) != 0)
+		   return r;
+
+		if (!*pdiskbno) {
+			/* filebno isn't allocated */
+			if ((r = alloc_block()) == -E_NO_DISK)
+				return -E_NO_DISK;
+
+			*pdiskbno = r;
+			memset(diskaddr(r), 0, BLKSIZE);
+		}
+
+		*blk = diskaddr(*pdiskbno);
+		return 0;
 }
 
 // Try to find a file named "name" in dir.  If so, set *file to it.
diff --git a/fs/serv.c b/fs/serv.c
index b54547f..e359bd2 100644
--- a/fs/serv.c
+++ b/fs/serv.c
@@ -207,6 +207,8 @@ serve_set_size(envid_t envid, struct Fsreq_set_size *req)
 int
 serve_read(envid_t envid, union Fsipc *ipc)
 {
+	int r;
+	struct OpenFile *o;
 	struct Fsreq_read *req = &ipc->read;
 	struct Fsret_read *ret = &ipc->readRet;
 
@@ -214,7 +216,17 @@ serve_read(envid_t envid, union Fsipc *ipc)
 		cprintf("serve_read %08x %08x %08x\n", envid, req->req_fileid, req->req_n);
 
 	// Lab 5: Your code here:
-	return 0;
+	if ((r = openfile_lookup(envid, req->req_fileid, &o)) != 0)
+		return r;
+
+	if (req->req_n == 0)
+		return 0;
+
+	if ((r = file_read(o->o_file, ret->ret_buf, req->req_n, o->o_fd->fd_offset)) <= 0)
+		return r;
+
+	o->o_fd->fd_offset += r;
+	return r;
 }
 
 
@@ -225,11 +237,24 @@ serve_read(envid_t envid, union Fsipc *ipc)
 int
 serve_write(envid_t envid, struct Fsreq_write *req)
 {
+	struct OpenFile *o;
+	int r;
+
 	if (debug)
 		cprintf("serve_write %08x %08x %08x\n", envid, req->req_fileid, req->req_n);
 
 	// LAB 5: Your code here.
-	panic("serve_write not implemented");
+	if ((r = openfile_lookup(envid, req->req_fileid, &o)) != 0)
+		return r;
+
+	if (req->req_n == 0)
+		return 0;
+
+	if ((r = file_write(o->o_file, req->req_buf, req->req_n, o->o_fd->fd_offset)) < 0)
+		return r;
+
+	o->o_fd->fd_offset += r;
+	return r;
 }
 
 // Stat ipc->stat.req_fileid.  Return the file's struct Stat to the
diff --git a/kern/env.c b/kern/env.c
index 0a6aac0..c6c309a 100644
--- a/kern/env.c
+++ b/kern/env.c
@@ -441,9 +441,6 @@ load_icode(struct Env *e, uint8_t *binary)
 void
 env_create(uint8_t *binary, enum EnvType type)
 {
-	// If this is the file server (type == ENV_TYPE_FS) give it I/O privileges.
-	// LAB 5: Your code here.
-
 	// LAB 3: Your code here.
 	struct Env *e_p;
 	int r;
@@ -452,6 +449,11 @@ env_create(uint8_t *binary, enum EnvType type)
 
 	load_icode(e_p, binary);
 	e_p->env_type = type;
+
+	// If this is the file server (type == ENV_TYPE_FS) give it I/O privileges.
+	// LAB 5: Your code here.
+	if (type == ENV_TYPE_FS)
+		e_p->env_tf.tf_eflags |= FL_IOPL_3;
 }
 
 //
diff --git a/kern/init.c b/kern/init.c
index 2a6acac..262a4cb 100644
--- a/kern/init.c
+++ b/kern/init.c
@@ -73,6 +73,7 @@ i386_init(void)
 	ENV_CREATE(TEST, ENV_TYPE_USER);
 #else
 	// Touch all you want.
+	//ENV_CREATE(user_testfile, ENV_TYPE_USER);
 	ENV_CREATE(user_icode, ENV_TYPE_USER);
 #endif // TEST*
 
diff --git a/kern/syscall.c b/kern/syscall.c
index 182e0fd..8f397a3 100644
--- a/kern/syscall.c
+++ b/kern/syscall.c
@@ -138,7 +138,29 @@ sys_env_set_trapframe(envid_t envid, struct Trapframe *tf)
 	// LAB 5: Your code here.
 	// Remember to check whether the user has supplied us with a good
 	// address!
-	panic("sys_env_set_trapframe not implemented");
+	int rval = 0;
+	struct Env *env;
+
+	if ((rval = envid2env(envid, &env, 1)) != 0) {
+		cprintf("here");
+		return rval;
+	}
+
+	user_mem_assert(env, (void*) tf, sizeof(struct Trapframe), PTE_W);
+
+	// set up the trap frmae
+	// run in RING 3
+	//tf->tf_es |= 3;
+	//tf->tf_ds |= 3;
+	tf->tf_cs |= 3;
+	tf->tf_ss |= 3;
+	// enable interrupts
+	tf->tf_eflags |= FL_IF;
+	// set IO Privilage level to Ring 0
+	tf->tf_eflags &= ~FL_IOPL_3;
+	// final set
+	env->env_tf = *tf;
+	return 0;
 }
 
 // Set the page fault upcall for 'envid' by modifying the corresponding struct
@@ -593,6 +615,10 @@ syscall(uint32_t syscallno, uint32_t a1, uint32_t a2, uint32_t a3, uint32_t a4,
 			r_val = sys_ipc_recv((void*) a1);
 			goto done;
 
+		case SYS_env_set_trapframe:
+			r_val = sys_env_set_trapframe((envid_t) a1, (struct Trapframe*) a2);
+			goto done;
+
 		default:
 			r_val = -E_INVAL;
 	}
diff --git a/kern/trap.c b/kern/trap.c
index 88eda70..b1dd03a 100644
--- a/kern/trap.c
+++ b/kern/trap.c
@@ -251,6 +251,16 @@ trap_dispatch(struct Trapframe *tf)
 			lapic_eoi();
 			sched_yield(); // never returns
 
+		// keyboard driver interrupt
+		case IRQ_OFFSET + IRQ_KBD:
+			kbd_intr();
+			return;
+
+		// serial interrupt
+		case IRQ_OFFSET + IRQ_SERIAL:
+			serial_intr();
+			return;
+
 		default:
 			goto bad;
 	}
diff --git a/lab5-questionary.txt b/lab5-questionary.txt
new file mode 100644
index 0000000..75b5209
--- /dev/null
+++ b/lab5-questionary.txt
@@ -0,0 +1,71 @@
+=== This template file contains questions you need to answer.
+=== Fill your answers on appropriate blank lines only.
+=== Don't start any line with three equal signs "===".
+=== Don't edit any lines starting from three equal signs.
+=== Use C notation to write numbers: 42 for decimal, 0x2a for hexadecimal.
+=== We may check most of the answers automatically, so "forty two" or
+=== "26+16" won't work for this example. Spaces are mostly ignored, so
+=== "  42  " is OK (without quotes of course). 
+=== When asked to specify address & instruction, do it in the form of
+=== gdb output "ADDRESS: INSTRUCTION", for example "0x7c26:  or  $0x1,%eax"
+=== Don't make lines longer than 80 characters. You don't need to fit your
+=== answer in a single line, you can start a new line at will.
+=== However, when asked to fill "a table" make each table raw a single line.
+
+=== Q How much disk space can be addressed by a single bitmap block
+===   when size of a block is 4KB? (number in _bytes_)
+
+134217728
+
+=== Q How much disk space can be addressed by a single bitmap block
+===   when size of a block is 512B? (number in _bytes_)
+
+2097152
+
+=== Q What is a maximum supported file size in JOS FS? (number in _bytes_)
+
+4235264
+
+=== Q Did you have to do anything else to ensure that the I/O
+===   privilege setting is saved and restored properly when you
+===   subsequently switch from one environment to another? Why? 
+===   (free form)
+
+No. The IOPL is in the EFLAGS register, and each env has its own copy
+of EFLAGS in his trapframe. During context switch, the kernel restores
+the full register state, including EFLAGS, using iret.
+
+=== Q How long approximately did it take you to do this lab?
+===   (number of hours for all partners combined)
+
+10
+
+====================================================================
+=== Q What challenge(s) have you chosen to implement? (specify
+===   challenge numbers separated by spaces, if more than one)
+
+2
+
+=== Q If the challenge requires changing the kernel source, list the
+===   files which you have changed/added during implementation.
+===   (one file per line, relative to lab directory containing .git/)
+
+fs/bc.c
+
+=== Q Describe you solution.
+===   (free form, up to 500 words, don't need to use all 500!)
+
+Created bc_evict function which looks for a block that might be hogging
+space. Meaning, it's mappes but haven't been used recently. If it finds one,
+it unmapps it. It does so by looking at the PTE_A bit, if it was on, turn it off.
+Therefore, next time we check the block, if PTE_A is on, it means that the block
+is not hogging, otherwise it is, and should be cleared. When cleaning a block, we
+flush it if needed.
+
+bc_evict can be called with any policy, OOM, limiting cache size etc.
+For testing I've added a cache limiting, when the bc is using too much
+memory for cacheing, we try to clear it. The check for cache limiting
+is checked at the bc_pgfault.
+
+
+Use the -DBC_EVICT flag to compile with the bc_evict.
diff --git a/lib/file.c b/lib/file.c
index 39025b2..7f53f9f 100644
--- a/lib/file.c
+++ b/lib/file.c
@@ -141,7 +141,20 @@ devfile_write(struct Fd *fd, const void *buf, size_t n)
 	// remember that write is always allowed to write *fewer*
 	// bytes than requested.
 	// LAB 5: Your code here
-	panic("devfile_write not implemented");
+	int r;
+
+	assert(n <= PGSIZE - (sizeof(int) + sizeof(size_t)));
+	fsipcbuf.write.req_fileid = fd->fd_file.id;
+	fsipcbuf.write.req_n = n;
+
+	memmove(fsipcbuf.write.req_buf, buf, n);
+
+	if ((r = fsipc(FSREQ_WRITE, NULL)) < 0)
+		return r;
+
+	assert(r <= n);
+	assert(r <= PGSIZE);
+	return n;
 }
 
 static int
diff --git a/lib/fork.c b/lib/fork.c
index 946f112..bca98f8 100644
--- a/lib/fork.c
+++ b/lib/fork.c
@@ -76,9 +76,20 @@ duppage(envid_t envid, unsigned pn)
 	int r;
 
 	// LAB 4: Your code here.
+	// LAB 5: Your code here.
 	void *addr = (void*)( pn * PGSIZE);
 
-	if ((uvpt[pn] & PTE_W) == PTE_W || (uvpt[pn] & PTE_COW) == PTE_COW) {
+	if ((uvpt[pn] & PTE_SHARE) == PTE_SHARE) {
+		// Shared memory
+		// Do not use 0xfff to mask out the relevant bits from tha page table
+		// entry. 0xfff picks up the accessed and dirty bits as well.
+		r = sys_page_map(0, addr, envid, addr, (uvpt[pn] & PTE_SYSCALL) | PTE_SHARE );
+
+		if (r != 0)
+			panic("duppage: sys_page_map: %e", r);
+
+	} else if ((uvpt[pn] & PTE_W) == PTE_W || (uvpt[pn] & PTE_COW) == PTE_COW) {
+		// Writable or Copy on write
 		r = sys_page_map(0, addr, envid, addr, PTE_U | PTE_P | PTE_COW);
 
 		if (r != 0)
@@ -88,7 +99,8 @@ duppage(envid_t envid, unsigned pn)
 
 		if (r != 0)
 			panic("duppage: sys_page_map: %e", r);
-	} else {
+	}else {
+		// Regular
 		r = sys_page_map(0, addr, envid, addr, PTE_U | PTE_P);
 
 		if (r != 0)
diff --git a/lib/spawn.c b/lib/spawn.c
index 73f68c3..1b8b733 100644
--- a/lib/spawn.c
+++ b/lib/spawn.c
@@ -301,6 +301,22 @@ static int
 copy_shared_pages(envid_t child)
 {
 	// LAB 5: Your code here.
+	int r;
+	uintptr_t addr = 0;
+	unsigned pn;
+
+	for (addr = 0; addr < UXSTACKTOP - PGSIZE; addr += PGSIZE) {
+		pn = PGNUM(addr);
+		if ((uvpd[PDX(addr)] & PTE_P) == PTE_P &&
+			(uvpt[pn] & PTE_P) == PTE_P &&
+			(uvpt[pn] & PTE_SHARE) == PTE_SHARE) {
+			r = sys_page_map(0, (void*) addr, child, (void*) addr, (uvpt[pn] & PTE_SYSCALL) | PTE_SHARE );
+
+			if (r != 0)
+				panic("duppage: sys_page_map: %e", r);
+		}
+	}
+
 	return 0;
 }
 
diff --git a/user/sh.c b/user/sh.c
index 26f501a..c1a09a5 100644
--- a/user/sh.c
+++ b/user/sh.c
@@ -55,7 +55,15 @@ again:
 			// then close the original 'fd'.
 
 			// LAB 5: Your code here.
-			panic("< redirection not implemented");
+			if ((fd = open(t, O_RDONLY)) < 0) {
+				cprintf("open %s for read only: %e", t, fd);
+				exit();
+			}
+
+			if (fd != 0) {
+				dup(fd, 0);
+				close(fd);
+			}
 			break;
 
 		case '>':	// Output redirection
-- 
1.9.1

